import { dirname, relative } from 'path';
import { promises } from 'fs';
import { setAdapter } from '@vanilla-extract/css/adapter';
import { transformCss } from '@vanilla-extract/css/transformCss';
import dedent from 'dedent';
import findUp from 'find-up';
import { build } from 'esbuild';
import evalCode from 'eval';
import { stringify } from 'javascript-stringify';
import isPlainObject from 'lodash/isPlainObject';
import crypto from 'crypto';

const hash = value => crypto.createHash('md5').update(value).digest('hex');

const vanillaCssNamespace = 'vanilla-extract-css-ns';
const cssFileFilter = /\.css\.(js|jsx|ts|tsx)$/;

const vanillaExtractFilescopePlugin = () => ({
  name: 'vanilla-extract-filescope',

  setup(build) {
    const packageJsonPath = findUp.sync('package.json', {
      cwd: build.initialOptions.absWorkingDir
    });

    if (!packageJsonPath) {
      throw new Error(`Can't find package.json`);
    }

    const {
      name
    } = require(packageJsonPath);

    const packageInfo = {
      name,
      path: packageJsonPath,
      dirname: dirname(packageJsonPath)
    };
    build.onLoad({
      filter: cssFileFilter
    }, async ({
      path
    }) => {
      const originalSource = await promises.readFile(path, 'utf-8');

      if (originalSource.indexOf('@vanilla-extract/css/fileScope') === -1) {
        const filePath = relative(packageInfo.dirname, path);
        const contents = `
        import { setFileScope, endFileScope } from "@vanilla-extract/css/fileScope";
        setFileScope("${filePath}", "${packageInfo.name}");
        ${originalSource}
        endFileScope()
        `;
        return {
          contents,
          resolveDir: dirname(path)
        };
      }
    });
  }

});

function vanillaExtractPlugin({
  outputCss = true,
  externals = [],
  runtime = false
} = {}) {
  if (runtime) {
    // If using runtime CSS then just apply fileScopes to code
    return vanillaExtractFilescopePlugin();
  }

  return {
    name: 'vanilla-extract',

    setup(build$1) {
      build$1.onResolve({
        filter: /vanilla\.css\?source=.*$/
      }, args => {
        return {
          path: args.path,
          namespace: vanillaCssNamespace
        };
      });
      build$1.onLoad({
        filter: /.*/,
        namespace: vanillaCssNamespace
      }, ({
        path
      }) => {
        var _path$match;

        const [, source] = (_path$match = path.match(/\?source=(.*)$/)) !== null && _path$match !== void 0 ? _path$match : [];

        if (!source) {
          throw new Error('No source in vanilla CSS file');
        }

        return {
          contents: Buffer.from(source, 'base64').toString('utf-8'),
          loader: 'css'
        };
      });
      build$1.onLoad({
        filter: cssFileFilter
      }, async ({
        path
      }) => {
        const result = await build({
          entryPoints: [path],
          metafile: true,
          bundle: true,
          external: ['@vanilla-extract', ...externals],
          platform: 'node',
          write: false,
          plugins: [vanillaExtractFilescopePlugin()],
          absWorkingDir: build$1.initialOptions.absWorkingDir
        });
        const {
          outputFiles,
          metafile
        } = result;

        if (!outputFiles || outputFiles.length !== 1) {
          throw new Error('Invalid child compilation');
        }

        function stringifyFileScope({
          packageName,
          filePath
        }) {
          return packageName ? `${filePath}$$$${packageName}` : filePath;
        }

        function parseFileScope(serialisedFileScope) {
          const [filePath, packageName] = serialisedFileScope.split('$$$');
          return {
            filePath,
            packageName
          };
        }

        const cssByFileScope = new Map();
        const localClassNames = new Set();
        const cssAdapter = {
          appendCss: (css, fileScope) => {
            if (outputCss) {
              var _cssByFileScope$get;

              const serialisedFileScope = stringifyFileScope(fileScope);
              const fileScopeCss = (_cssByFileScope$get = cssByFileScope.get(serialisedFileScope)) !== null && _cssByFileScope$get !== void 0 ? _cssByFileScope$get : [];
              fileScopeCss.push(css);
              cssByFileScope.set(serialisedFileScope, fileScopeCss);
            }
          },
          registerClassName: className => {
            localClassNames.add(className);
          },
          onEndFileScope: () => {}
        };
        setAdapter(cssAdapter);
        const sourceWithBoundLoaderInstance = `require('@vanilla-extract/css/adapter').setAdapter(__adapter__);${outputFiles[0].text}`;
        const evalResult = evalCode(sourceWithBoundLoaderInstance, path, {
          console,
          __adapter__: cssAdapter
        }, true);
        const cssRequests = [];

        for (const [serialisedFileScope, fileScopeCss] of cssByFileScope) {
          const {
            packageName,
            filePath
          } = parseFileScope(serialisedFileScope);
          const css = transformCss({
            localClassNames: Array.from(localClassNames),
            cssObjs: fileScopeCss
          }).join('\n');
          const base64Css = Buffer.from(css, 'utf-8').toString('base64');
          const fileName = packageName ? `${packageName}/${filePath}` : filePath;
          cssRequests.push(`${fileName}.vanilla.css?source=${base64Css}`);
        }

        const contents = serializeVanillaModule(cssRequests, evalResult);
        return {
          contents,
          loader: 'js',
          watchFiles: Object.keys((metafile === null || metafile === void 0 ? void 0 : metafile.inputs) || {})
        };
      });
    }

  };
}

const stringifyExports = (recipeImports, value) => stringify(value, (value, _indent, next) => {
  const valueType = typeof value;

  if (valueType === 'string' || valueType === 'number' || valueType === 'undefined' || value === null || Array.isArray(value) || isPlainObject(value)) {
    return next(value);
  }

  if (valueType === 'function' && value.__recipe__) {
    const {
      importPath,
      importName,
      args
    } = value.__recipe__;

    if (typeof importPath !== 'string' || typeof importName !== 'string' || !Array.isArray(args)) {
      throw new Error('Invalid recipe');
    }

    try {
      const hashedImportName = `_${hash(`${importName}${importPath}`).slice(0, 5)}`;
      recipeImports.add(`import { ${importName} as ${hashedImportName} } from '${importPath}';`);
      return `${hashedImportName}(${args.map(arg => stringifyExports(recipeImports, arg)).join(',')})`;
    } catch (err) {
      console.error(err);
      throw new Error('Invalid recipe.');
    }
  }

  throw new Error(dedent`
        Invalid exports.

        You can only export plain objects, arrays, strings, numbers and null/undefined.
      `);
}, 0, {
  references: true,
  // Allow circular references
  maxDepth: Infinity,
  maxValues: Infinity
});

const serializeVanillaModule = (cssRequests, exports) => {
  const cssImports = cssRequests.map(request => {
    return `import '${request}';`;
  });
  const recipeImports = new Set();
  const moduleExports = Object.keys(exports).map(key => key === 'default' ? `export default ${stringifyExports(recipeImports, exports[key])};` : `export var ${key} = ${stringifyExports(recipeImports, exports[key])};`);
  const outputCode = [...cssImports, ...recipeImports, ...moduleExports];
  return outputCode.join('\n');
};

export { vanillaExtractPlugin };
