import { transformCss } from '../transformCss/dist/vanilla-extract-css-transformCss.esm.js';
import { setAdapter, appendCss, registerClassName } from '../adapter/dist/vanilla-extract-css-adapter.esm.js';
import hash from '@emotion/hash';
import { getAndIncrementRefCounter, getFileScope } from '../fileScope/dist/vanilla-extract-css-fileScope.esm.js';
import { walkObject, get } from '@vanilla-extract/private';
import cssesc from 'cssesc';
import dedent from 'dedent';
import 'css-selector-parser';

const stylesheets = {};
const localClassNames = new Set();
let bufferedCSSObjs = [];

function getStylesheet({
  packageName,
  filePath
}) {
  const fileScopeId = packageName ? `${packageName}${filePath}` : filePath;

  if (stylesheets[fileScopeId]) {
    return stylesheets[fileScopeId];
  }

  const styleEl = document.createElement('style');
  document.head.appendChild(styleEl);

  if (!styleEl.sheet) {
    throw new Error(`Couldn't create stylesheet`);
  }

  stylesheets[fileScopeId] = styleEl.sheet;
  return styleEl.sheet;
}

const browserRuntimeAdapter = {
  appendCss: cssObj => {
    bufferedCSSObjs.push(cssObj);
  },
  registerClassName: className => {
    localClassNames.add(className);
  },
  onEndFileScope: fileScope => {
    const css = transformCss({
      localClassNames: Array.from(localClassNames),
      cssObjs: bufferedCSSObjs
    });
    const stylesheet = getStylesheet(fileScope);
    const existingRuleCount = stylesheet.cssRules.length;
    let ruleIndex = 0;

    for (const rule of css) {
      try {
        if (ruleIndex < existingRuleCount) {
          stylesheet.deleteRule(ruleIndex);
        }

        stylesheet.insertRule(rule, ruleIndex++);
      } catch (e) {
        console.warn(`Failed to insert rule\n${rule}`); // insert placeholder rule to keep index count correct

        stylesheet.insertRule('.--placeholder-rule--{}', ruleIndex - 1);
      }
    } // Delete remaining rules


    while (ruleIndex < existingRuleCount) {
      stylesheet.deleteRule(ruleIndex++);
    }

    bufferedCSSObjs = [];
  }
};

if (typeof window !== 'undefined') {
  setAdapter(browserRuntimeAdapter);
}

function getDevPrefix(debugId) {
  const parts = debugId ? [debugId] : [];
  const {
    filePath
  } = getFileScope();
  const matches = filePath.match(/(?<dir>[^\/]*)?\/?(?<file>[^\/]*)\.css\.(ts|js|tsx|jsx)$/);

  if (matches && matches.groups) {
    const {
      dir,
      file
    } = matches.groups;
    parts.unshift(file && file !== 'index' ? file : dir);
  }

  return parts.join('_');
}

function generateIdentifier(debugId) {
  // Convert ref count to base 36 for optimal hash lengths
  const refCount = getAndIncrementRefCounter().toString(36);
  const {
    filePath,
    packageName
  } = getFileScope();
  const fileScopeHash = hash(packageName ? `${packageName}${filePath}` : filePath);
  let identifier = `${fileScopeHash}${refCount}`;

  if (process.env.NODE_ENV !== 'production') {
    const devPrefix = getDevPrefix(debugId);

    if (devPrefix) {
      identifier = `${devPrefix}__${identifier}`;
    }
  }

  return identifier.match(/^[0-9]/) ? `_${identifier}` : identifier;
}

function createVar(debugId) {
  // Convert ref count to base 36 for optimal hash lengths
  const refCount = getAndIncrementRefCounter().toString(36);
  const {
    filePath,
    packageName
  } = getFileScope();
  const fileScopeHash = hash(packageName ? `${packageName}${filePath}` : filePath);
  const varName = process.env.NODE_ENV !== 'production' && debugId ? `${debugId}__${fileScopeHash}${refCount}` : `${fileScopeHash}${refCount}`; // Dashify CSS var names to replicate postcss-js behaviour
  // See https://github.com/postcss/postcss-js/blob/d5127d4278c133f333f1c66f990f3552a907128e/parser.js#L30

  const cssVarName = cssesc(varName.match(/^[0-9]/) ? `_${varName}` : varName, {
    isIdentifier: true
  }).replace(/([A-Z])/g, '-$1').toLowerCase();
  return `var(--${cssVarName})`;
}
function fallbackVar(...values) {
  let finalValue = '';
  values.reverse().forEach(value => {
    if (finalValue === '') {
      finalValue = String(value);
    } else {
      if (typeof value !== 'string' || !/^var\(--.*\)$/.test(value)) {
        throw new Error(`Invalid variable name: ${value}`);
      }

      finalValue = value.replace(/\)$/, `, ${finalValue})`);
    }
  });
  return finalValue;
}
function assignVars(varContract, tokens) {
  const varSetters = {};
  /* TODO
  - validate new variables arn't set
  - validate arrays have the same length as contract
  */

  walkObject(tokens, (value, path) => {
    varSetters[get(varContract, path)] = String(value);
  });
  return varSetters;
}
function createThemeContract(themeContract) {
  return walkObject(themeContract, (_value, path) => {
    return createVar(path.join('-'));
  });
}

function createGlobalTheme(selector, arg2, arg3) {
  const shouldCreateVars = Boolean(!arg3);
  const themeVars = shouldCreateVars ? createThemeContract(arg2) : arg2;
  const tokens = shouldCreateVars ? arg2 : arg3;
  appendCss({
    type: 'global',
    selector: selector,
    rule: {
      vars: assignVars(themeVars, tokens)
    }
  }, getFileScope());

  if (shouldCreateVars) {
    return themeVars;
  }
}
function createTheme(arg1, arg2, arg3) {
  const themeClassName = generateIdentifier(typeof arg2 === 'object' ? arg3 : arg2);
  registerClassName(themeClassName);
  const vars = typeof arg2 === 'object' ? createGlobalTheme(themeClassName, arg1, arg2) : createGlobalTheme(themeClassName, arg1);
  return vars ? [themeClassName, vars] : themeClassName;
}

function style(rule, debugId) {
  const className = generateIdentifier(debugId);
  registerClassName(className);
  appendCss({
    type: 'local',
    selector: className,
    rule
  }, getFileScope());
  return className;
}
function globalStyle(selector, rule) {
  appendCss({
    type: 'global',
    selector,
    rule
  }, getFileScope());
}
function fontFace(rule, debugId) {
  const fontFamily = `"${cssesc(generateIdentifier(debugId), {
    quotes: 'double'
  })}"`;

  if ('fontFamily' in rule) {
    throw new Error(dedent`
          This function creates and returns a hashed font-family name, so the "fontFamily" property should not be provided.
  
          If you'd like to define a globally scoped custom font, you can use the "globalFontFace" function instead.
        `);
  }

  appendCss({
    type: 'fontFace',
    rule: { ...rule,
      fontFamily
    }
  }, getFileScope());
  return fontFamily;
}
function globalFontFace(fontFamily, rule) {
  appendCss({
    type: 'fontFace',
    rule: { ...rule,
      fontFamily
    }
  }, getFileScope());
}
function keyframes(rule, debugId) {
  const name = cssesc(generateIdentifier(debugId), {
    isIdentifier: true
  });
  appendCss({
    type: 'keyframes',
    name,
    rule
  }, getFileScope());
  return name;
}
function globalKeyframes(name, rule) {
  appendCss({
    type: 'keyframes',
    name,
    rule
  }, getFileScope());
}
function styleVariants(...args) {
  if (typeof args[1] === 'function') {
    const data = args[0];
    const mapData = args[1];
    const debugId = args[2];
    const classMap = {};

    for (const key in data) {
      classMap[key] = style(mapData(data[key], key), debugId ? `${debugId}_${key}` : key);
    }

    return classMap;
  }

  const styleMap = args[0];
  const debugId = args[1];
  const classMap = {};

  for (const key in styleMap) {
    classMap[key] = style(styleMap[key], debugId ? `${debugId}_${key}` : key);
  }

  return classMap;
}

function composeStylesIntoSet(set, ...classNames) {
  for (const className of classNames) {
    if (className.length === 0) {
      continue;
    }

    if (typeof className === 'string') {
      if (className.includes(' ')) {
        composeStylesIntoSet(set, ...className.trim().split(' '));
      } else {
        set.add(className);
      }
    } else if (Array.isArray(className)) {
      composeStylesIntoSet(set, ...className);
    }
  }
}

function composeStyles(...classNames) {
  const set = new Set();
  composeStylesIntoSet(set, ...classNames);
  return Array.from(set).join(' ');
}

export { assignVars, composeStyles, createGlobalTheme, createTheme, createThemeContract, createVar, fallbackVar, fontFace, generateIdentifier, globalFontFace, globalKeyframes, globalStyle, keyframes, style, styleVariants };
