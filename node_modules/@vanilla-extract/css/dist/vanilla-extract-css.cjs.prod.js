'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var transformCss_dist_vanillaExtractCssTransformCss = require('../transformCss/dist/vanilla-extract-css-transformCss.cjs.prod.js');
var adapter_dist_vanillaExtractCssAdapter = require('../adapter/dist/vanilla-extract-css-adapter.cjs.prod.js');
var hash = require('@emotion/hash');
var fileScope_dist_vanillaExtractCssFileScope = require('../fileScope/dist/vanilla-extract-css-fileScope.cjs.prod.js');
var _private = require('@vanilla-extract/private');
var cssesc = require('cssesc');
var dedent = require('dedent');
require('css-selector-parser');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var hash__default = /*#__PURE__*/_interopDefault(hash);
var cssesc__default = /*#__PURE__*/_interopDefault(cssesc);
var dedent__default = /*#__PURE__*/_interopDefault(dedent);

const stylesheets = {};
const localClassNames = new Set();
let bufferedCSSObjs = [];

function getStylesheet({
  packageName,
  filePath
}) {
  const fileScopeId = packageName ? `${packageName}${filePath}` : filePath;

  if (stylesheets[fileScopeId]) {
    return stylesheets[fileScopeId];
  }

  const styleEl = document.createElement('style');
  document.head.appendChild(styleEl);

  if (!styleEl.sheet) {
    throw new Error(`Couldn't create stylesheet`);
  }

  stylesheets[fileScopeId] = styleEl.sheet;
  return styleEl.sheet;
}

const browserRuntimeAdapter = {
  appendCss: cssObj => {
    bufferedCSSObjs.push(cssObj);
  },
  registerClassName: className => {
    localClassNames.add(className);
  },
  onEndFileScope: fileScope => {
    const css = transformCss_dist_vanillaExtractCssTransformCss.transformCss({
      localClassNames: Array.from(localClassNames),
      cssObjs: bufferedCSSObjs
    });
    const stylesheet = getStylesheet(fileScope);
    const existingRuleCount = stylesheet.cssRules.length;
    let ruleIndex = 0;

    for (const rule of css) {
      try {
        if (ruleIndex < existingRuleCount) {
          stylesheet.deleteRule(ruleIndex);
        }

        stylesheet.insertRule(rule, ruleIndex++);
      } catch (e) {
        console.warn(`Failed to insert rule\n${rule}`); // insert placeholder rule to keep index count correct

        stylesheet.insertRule('.--placeholder-rule--{}', ruleIndex - 1);
      }
    } // Delete remaining rules


    while (ruleIndex < existingRuleCount) {
      stylesheet.deleteRule(ruleIndex++);
    }

    bufferedCSSObjs = [];
  }
};

if (typeof window !== 'undefined') {
  adapter_dist_vanillaExtractCssAdapter.setAdapter(browserRuntimeAdapter);
}

function generateIdentifier(debugId) {
  // Convert ref count to base 36 for optimal hash lengths
  const refCount = fileScope_dist_vanillaExtractCssFileScope.getAndIncrementRefCounter().toString(36);
  const {
    filePath,
    packageName
  } = fileScope_dist_vanillaExtractCssFileScope.getFileScope();
  const fileScopeHash = hash__default['default'](packageName ? `${packageName}${filePath}` : filePath);
  let identifier = `${fileScopeHash}${refCount}`;

  return identifier.match(/^[0-9]/) ? `_${identifier}` : identifier;
}

function createVar(debugId) {
  // Convert ref count to base 36 for optimal hash lengths
  const refCount = fileScope_dist_vanillaExtractCssFileScope.getAndIncrementRefCounter().toString(36);
  const {
    filePath,
    packageName
  } = fileScope_dist_vanillaExtractCssFileScope.getFileScope();
  const fileScopeHash = hash__default['default'](packageName ? `${packageName}${filePath}` : filePath);
  const varName = `${fileScopeHash}${refCount}`; // Dashify CSS var names to replicate postcss-js behaviour
  // See https://github.com/postcss/postcss-js/blob/d5127d4278c133f333f1c66f990f3552a907128e/parser.js#L30

  const cssVarName = cssesc__default['default'](varName.match(/^[0-9]/) ? `_${varName}` : varName, {
    isIdentifier: true
  }).replace(/([A-Z])/g, '-$1').toLowerCase();
  return `var(--${cssVarName})`;
}
function fallbackVar(...values) {
  let finalValue = '';
  values.reverse().forEach(value => {
    if (finalValue === '') {
      finalValue = String(value);
    } else {
      if (typeof value !== 'string' || !/^var\(--.*\)$/.test(value)) {
        throw new Error(`Invalid variable name: ${value}`);
      }

      finalValue = value.replace(/\)$/, `, ${finalValue})`);
    }
  });
  return finalValue;
}
function assignVars(varContract, tokens) {
  const varSetters = {};
  /* TODO
  - validate new variables arn't set
  - validate arrays have the same length as contract
  */

  _private.walkObject(tokens, (value, path) => {
    varSetters[_private.get(varContract, path)] = String(value);
  });
  return varSetters;
}
function createThemeContract(themeContract) {
  return _private.walkObject(themeContract, (_value, path) => {
    return createVar(path.join('-'));
  });
}

function createGlobalTheme(selector, arg2, arg3) {
  const shouldCreateVars = Boolean(!arg3);
  const themeVars = shouldCreateVars ? createThemeContract(arg2) : arg2;
  const tokens = shouldCreateVars ? arg2 : arg3;
  adapter_dist_vanillaExtractCssAdapter.appendCss({
    type: 'global',
    selector: selector,
    rule: {
      vars: assignVars(themeVars, tokens)
    }
  }, fileScope_dist_vanillaExtractCssFileScope.getFileScope());

  if (shouldCreateVars) {
    return themeVars;
  }
}
function createTheme(arg1, arg2, arg3) {
  const themeClassName = generateIdentifier();
  adapter_dist_vanillaExtractCssAdapter.registerClassName(themeClassName);
  const vars = typeof arg2 === 'object' ? createGlobalTheme(themeClassName, arg1, arg2) : createGlobalTheme(themeClassName, arg1);
  return vars ? [themeClassName, vars] : themeClassName;
}

function style(rule, debugId) {
  const className = generateIdentifier();
  adapter_dist_vanillaExtractCssAdapter.registerClassName(className);
  adapter_dist_vanillaExtractCssAdapter.appendCss({
    type: 'local',
    selector: className,
    rule
  }, fileScope_dist_vanillaExtractCssFileScope.getFileScope());
  return className;
}
function globalStyle(selector, rule) {
  adapter_dist_vanillaExtractCssAdapter.appendCss({
    type: 'global',
    selector,
    rule
  }, fileScope_dist_vanillaExtractCssFileScope.getFileScope());
}
function fontFace(rule, debugId) {
  const fontFamily = `"${cssesc__default['default'](generateIdentifier(), {
    quotes: 'double'
  })}"`;

  if ('fontFamily' in rule) {
    throw new Error(dedent__default['default']`
          This function creates and returns a hashed font-family name, so the "fontFamily" property should not be provided.
  
          If you'd like to define a globally scoped custom font, you can use the "globalFontFace" function instead.
        `);
  }

  adapter_dist_vanillaExtractCssAdapter.appendCss({
    type: 'fontFace',
    rule: { ...rule,
      fontFamily
    }
  }, fileScope_dist_vanillaExtractCssFileScope.getFileScope());
  return fontFamily;
}
function globalFontFace(fontFamily, rule) {
  adapter_dist_vanillaExtractCssAdapter.appendCss({
    type: 'fontFace',
    rule: { ...rule,
      fontFamily
    }
  }, fileScope_dist_vanillaExtractCssFileScope.getFileScope());
}
function keyframes(rule, debugId) {
  const name = cssesc__default['default'](generateIdentifier(), {
    isIdentifier: true
  });
  adapter_dist_vanillaExtractCssAdapter.appendCss({
    type: 'keyframes',
    name,
    rule
  }, fileScope_dist_vanillaExtractCssFileScope.getFileScope());
  return name;
}
function globalKeyframes(name, rule) {
  adapter_dist_vanillaExtractCssAdapter.appendCss({
    type: 'keyframes',
    name,
    rule
  }, fileScope_dist_vanillaExtractCssFileScope.getFileScope());
}
function styleVariants(...args) {
  if (typeof args[1] === 'function') {
    const data = args[0];
    const mapData = args[1];
    args[2];
    const classMap = {};

    for (const key in data) {
      classMap[key] = style(mapData(data[key], key));
    }

    return classMap;
  }

  const styleMap = args[0];
  args[1];
  const classMap = {};

  for (const key in styleMap) {
    classMap[key] = style(styleMap[key]);
  }

  return classMap;
}

function composeStylesIntoSet(set, ...classNames) {
  for (const className of classNames) {
    if (className.length === 0) {
      continue;
    }

    if (typeof className === 'string') {
      if (className.includes(' ')) {
        composeStylesIntoSet(set, ...className.trim().split(' '));
      } else {
        set.add(className);
      }
    } else if (Array.isArray(className)) {
      composeStylesIntoSet(set, ...className);
    }
  }
}

function composeStyles(...classNames) {
  const set = new Set();
  composeStylesIntoSet(set, ...classNames);
  return Array.from(set).join(' ');
}

exports.assignVars = assignVars;
exports.composeStyles = composeStyles;
exports.createGlobalTheme = createGlobalTheme;
exports.createTheme = createTheme;
exports.createThemeContract = createThemeContract;
exports.createVar = createVar;
exports.fallbackVar = fallbackVar;
exports.fontFace = fontFace;
exports.generateIdentifier = generateIdentifier;
exports.globalFontFace = globalFontFace;
exports.globalKeyframes = globalKeyframes;
exports.globalStyle = globalStyle;
exports.keyframes = keyframes;
exports.style = style;
exports.styleVariants = styleVariants;
