import { getVarName } from '@vanilla-extract/private';
import cssesc from 'cssesc';
import { CssSelectorParser } from 'css-selector-parser';
import dedent from 'dedent';

function escapeRegex(string) {
  return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

const parser = new CssSelectorParser();
parser.registerSelectorPseudos('has');
parser.registerNestingOperators('>', '+', '~');
parser.registerAttrEqualityMods('^', '$', '*', '~');
parser.enableSubstitutes();
const validateSelector = (selector, targetClassName) => {
  const replaceTarget = () => {
    const targetRegex = new RegExp(`.${escapeRegex(cssesc(targetClassName, {
      isIdentifier: true
    }))}`, 'g');
    return selector.replace(targetRegex, '&');
  };

  return selector.split(',').map(selectorPart => {
    if (selectorPart.indexOf(targetClassName) === -1) {
      throw new Error(dedent`
          Invalid selector: ${replaceTarget()}
      
          Selectors must target the ampersand character ('&'), which refers to the generated class name, e.g. '&:nth-child(2n)'
        `);
    }

    let currentRule;

    try {
      const result = parser.parse(selectorPart);

      if (result.type === 'ruleSet') {
        currentRule = result.rule;
      } else {
        throw new Error();
      }
    } catch (err) {
      throw new Error(`Invalid selector: ${replaceTarget()}`);
    }

    while (currentRule.rule) {
      currentRule = currentRule.rule;
    }

    const targetRule = currentRule;

    if (!Array.isArray(targetRule.classNames) || !targetRule.classNames.find(className => className === targetClassName)) {
      throw new Error(dedent`
          Invalid selector: ${replaceTarget()}
      
          Style selectors must end with the '&' character (along with any modifiers), e.g. ${'`${parent} &`'} or ${'`${parent} &:hover`'}.
          
          This is to ensure that each style block only affects the styling of a single class.
          
          If your selector is targeting another class, you should move it to the style definition for that class, e.g. given we have styles for 'parent' and 'child' elements, instead of adding a selector of ${'`& ${child}`'}) to 'parent', you should add ${'`${parent} &`'} to 'child').
          
          If your selector is targeting something global, use the 'globalStyle' function instead, e.g. if you wanted to write ${'`& h1`'}, you should instead write 'globalStyle(${'`${parent} h1`'}, { ... })'
        `);
    }
  });
};

function forEach(obj, fn) {
  for (const key in obj) {
    fn(obj[key], key);
  }
}
function omit(obj, omitKeys) {
  let result = {};

  for (const key in obj) {
    if (omitKeys.indexOf(key) === -1) {
      result[key] = obj[key];
    }
  }

  return result;
}
function mapKeys(obj, fn) {
  let result = {};

  for (const key in obj) {
    result[fn(obj[key], key)] = obj[key];
  }

  return result;
}
function isEqual(a, b) {
  if (typeof a !== typeof b) {
    return false;
  }

  if (typeof a === 'object') {
    const keys1 = Object.keys(a);
    const keys2 = Object.keys(b);

    if (keys1.length !== keys2.length) {
      return false;
    }

    for (const key in a) {
      if (!isEqual(a[key], b[key])) {
        return false;
      }
    }

    return true;
  } else {
    return a === b;
  }
}

const UNITLESS = {
  animationIterationCount: true,
  borderImage: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexShrink: true,
  fontWeight: true,
  gridArea: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnStart: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowStart: true,
  initialLetter: true,
  lineClamp: true,
  lineHeight: true,
  maxLines: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  webkitLineClamp: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // svg properties
  fillOpacity: true,
  floodOpacity: true,
  maskBorder: true,
  maskBorderOutset: true,
  maskBorderSlice: true,
  maskBorderWidth: true,
  shapeImageThreshold: true,
  stopOpacity: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
const simplePseudos = [':-moz-any-link', ':-moz-full-screen', ':-moz-placeholder', ':-moz-read-only', ':-moz-read-write', ':-ms-fullscreen', ':-ms-input-placeholder', ':-webkit-any-link', ':-webkit-full-screen', '::-moz-placeholder', '::-moz-progress-bar', '::-moz-range-progress', '::-moz-range-thumb', '::-moz-range-track', '::-moz-selection', '::-ms-backdrop', '::-ms-browse', '::-ms-check', '::-ms-clear', '::-ms-fill', '::-ms-fill-lower', '::-ms-fill-upper', '::-ms-reveal', '::-ms-thumb', '::-ms-ticks-after', '::-ms-ticks-before', '::-ms-tooltip', '::-ms-track', '::-ms-value', '::-webkit-backdrop', '::-webkit-input-placeholder', '::-webkit-progress-bar', '::-webkit-progress-inner-value', '::-webkit-progress-value', '::-webkit-slider-runnable-track', '::-webkit-slider-thumb', '::after', '::backdrop', '::before', '::cue', '::first-letter', '::first-line', '::grammar-error', '::placeholder', '::selection', '::spelling-error', ':active', ':after', ':any-link', ':before', ':blank', ':checked', ':default', ':defined', ':disabled', ':empty', ':enabled', ':first', ':first-child', ':first-letter', ':first-line', ':first-of-type', ':focus', ':focus-visible', ':focus-within', ':fullscreen', ':hover', ':in-range', ':indeterminate', ':invalid', ':last-child', ':last-of-type', ':left', ':link', ':only-child', ':only-of-type', ':optional', ':out-of-range', ':placeholder-shown', ':read-only', ':read-write', ':required', ':right', ':root', ':scope', ':target', ':valid', ':visited'];

function dashify(str) {
  return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();
}

const DOUBLE_SPACE = '  ';
const simplePseudoSet = new Set(simplePseudos);
const specialKeys = [...simplePseudos, '@media', '@supports', 'selectors'];

class Stylesheet {
  constructor(localClassNames) {
    this.rules = [];
    this.conditionalRules = [];
    this.fontFaceRules = [];
    this.keyframesRules = [];
    this.localClassNameRegex = localClassNames.length > 0 ? RegExp(`(${localClassNames.join('|')})`, 'g') : null;
  }

  processCssObj(root) {
    if (root.type === 'fontFace') {
      this.fontFaceRules.push(root.rule);
      return;
    }

    if (root.type === 'keyframes') {
      this.keyframesRules.push(root);
      return;
    } // Add main styles


    const mainRule = omit(root.rule, specialKeys);
    this.addRule({
      selector: root.selector,
      rule: mainRule
    });
    this.transformSimplePsuedos(root, root.rule);
    this.transformMedia(root, root.rule['@media']);
    this.transformSupports(root, root.rule['@supports']);
    this.transformSelectors(root, root.rule);
  }

  addRule(cssRule) {
    // Run `pixelifyProperties` before `transformVars` as we don't want to pixelify CSS Vars
    const rule = this.transformVars(this.pixelifyProperties(cssRule.rule));
    const selector = this.transformSelector(cssRule.selector);

    if (cssRule.conditions) {
      this.conditionalRules.push({
        selector,
        rule,
        conditions: cssRule.conditions.sort()
      });
    } else {
      this.rules.push({
        selector,
        rule
      });
    }
  }

  pixelifyProperties(cssRule) {
    forEach(cssRule, (value, key) => {
      if (typeof value === 'number' && value !== 0 && !UNITLESS[key]) {
        // @ts-expect-error Any ideas?
        cssRule[key] = `${value}px`;
      }
    });
    return cssRule;
  }

  transformVars({
    vars,
    ...rest
  }) {
    if (!vars) {
      return rest;
    }

    return { ...mapKeys(vars, (_value, key) => getVarName(key)),
      ...rest
    };
  }

  transformSelector(selector) {
    return this.localClassNameRegex ? selector.replace(this.localClassNameRegex, (_, className, index) => {
      if (index > 0 && selector[index - 1] === '.') {
        return className;
      }

      return `.${cssesc(className, {
        isIdentifier: true
      })}`;
    }) : selector;
  }

  transformSelectors(root, rule, conditions) {
    forEach(rule.selectors, (selectorRule, selector) => {
      if (root.type !== 'local') {
        throw new Error(`Selectors are not allowed within ${root.type === 'global' ? '"globalStyle"' : '"selectors"'}`);
      }

      const transformedSelector = this.transformSelector(selector.replace(RegExp('&', 'g'), root.selector));
      validateSelector(transformedSelector, root.selector);
      this.addRule({
        conditions,
        selector: transformedSelector,
        rule: omit(selectorRule, specialKeys)
      });
      const selectorRoot = {
        type: 'selector',
        selector: transformedSelector,
        rule: selectorRule
      };
      this.transformSupports(selectorRoot, selectorRule['@supports'], conditions);
      this.transformMedia(selectorRoot, selectorRule['@media'], conditions);
    });
  }

  transformMedia(root, rules, parentConditions = []) {
    forEach(rules, (mediaRule, query) => {
      const conditions = [`@media ${query}`, ...parentConditions];
      this.addRule({
        conditions,
        selector: root.selector,
        rule: omit(mediaRule, specialKeys)
      });

      if (root.type === 'local') {
        this.transformSimplePsuedos(root, mediaRule, conditions);
        this.transformSelectors(root, mediaRule, conditions);
      }

      this.transformSupports(root, mediaRule['@supports'], conditions);
    });
  }

  transformSupports(root, rules, parentConditions = []) {
    forEach(rules, (supportsRule, query) => {
      const conditions = [`@supports ${query}`, ...parentConditions];
      this.addRule({
        conditions,
        selector: root.selector,
        rule: omit(supportsRule, specialKeys)
      });

      if (root.type === 'local') {
        this.transformSimplePsuedos(root, supportsRule, conditions);
        this.transformSelectors(root, supportsRule, conditions);
      }

      this.transformMedia(root, supportsRule['@media'], conditions);
    });
  }

  transformSimplePsuedos(root, rule, conditions) {
    for (const key of Object.keys(rule)) {
      // Process simple psuedos
      if (simplePseudoSet.has(key)) {
        if (root.type !== 'local') {
          throw new Error(`Simple pseudos are not valid in ${root.type === 'global' ? '"globalStyle"' : '"selectors"'}`);
        }

        this.addRule({
          conditions,
          selector: `${root.selector}${key}`,
          rule: rule[key]
        });
      }
    }
  }

  toPostcssJs() {
    const styles = {};

    if (this.fontFaceRules.length > 0) {
      styles['@font-face'] = this.fontFaceRules;
    }

    this.keyframesRules.forEach(rule => {
      styles[`@keyframes ${rule.name}`] = rule.rule;
    });

    for (const rule of [...this.rules, ...this.conditionalRules]) {
      if (rule.conditions && isEqual(styles[rule.selector], rule.rule)) {
        // Ignore conditional rules if they are identical to a non-conditional rule
        continue;
      }

      if (Object.keys(rule.rule).length === 0) {
        // Ignore empty rules
        continue;
      }

      let styleNode = styles;

      for (const condition of rule.conditions || []) {
        if (!styleNode[condition]) {
          styleNode[condition] = {};
        }

        styleNode = styleNode[condition];
      }

      styleNode[rule.selector] = { ...styleNode[rule.selector],
        ...rule.rule
      };
    }

    return styles;
  }

  toCss() {
    const styles = this.toPostcssJs();

    function walkCss(v, indent = '') {
      const rules = [];

      for (const key of Object.keys(v)) {
        const value = v[key];

        if (value && Array.isArray(value)) {
          rules.push(...value.map(v => walkCss({
            [key]: v
          }, indent).join('\n')));
        } else if (value && typeof value === 'object') {
          rules.push(`${indent}${key} {\n${walkCss(value, indent + DOUBLE_SPACE).join('\n')}\n${indent}}`);
        } else {
          rules.push(`${indent}${key.startsWith('--') ? key : dashify(key)}: ${value};`);
        }
      }

      return rules;
    }

    return walkCss(styles);
  }

}

function transformCss({
  localClassNames,
  cssObjs
}) {
  const stylesheet = new Stylesheet(localClassNames);

  for (const root of cssObjs) {
    stylesheet.processCssObj(root);
  }

  return stylesheet.toCss();
}

export { simplePseudos, transformCss };
